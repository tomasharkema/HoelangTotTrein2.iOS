//
//  Advice+JsonGen.swift
//
//  Auto generated by swift-json-gen on Sat, 23 Jan 2016 12:31:24 GMT
//  See for details: https://github.com/tomlokhorst/swift-json-gen
//

import Foundation

extension FareStatus {
  static func decodeJson(json: AnyObject) throws -> FareStatus {
    guard let rawValue = json as? String else {
      throw JsonDecodeError.WrongType(rawValue: json, expectedType: "String")
    }
    guard let value = FareStatus(rawValue: rawValue) else {
      throw JsonDecodeError.WrongEnumRawValue(rawValue: rawValue, enumType: "FareStatus")
    }

    return value
  }

  func encodeJson() -> String {
    return rawValue
  }
}

extension FareTime {
  static func decodeJson(json: AnyObject) throws -> FareTime {
    guard let dict = json as? [String : AnyObject] else {
      throw JsonDecodeError.WrongType(rawValue: json, expectedType: "Object")
    }

    var errors: [String: JsonDecodeError] = [:]

    var planned_optional: Double?
    var actual_optional: Double?

    if let planned_field: AnyObject = dict["planned"] {
      do {
        planned_optional = try Double.decodeJson(planned_field)
      }
      catch let error as JsonDecodeError {
        errors["planned"] = error
      }
    }
    else {
      errors["planned"] = JsonDecodeError.MissingField
    }

    if let actual_field: AnyObject = dict["actual"] {
      do {
        actual_optional = try Double.decodeJson(actual_field)
      }
      catch let error as JsonDecodeError {
        errors["actual"] = error
      }
    }
    else {
      errors["actual"] = JsonDecodeError.MissingField
    }

    guard
      let planned = planned_optional,
      let actual = actual_optional
    else {
      throw JsonDecodeError.StructErrors(type: "FareTime", errors: errors)
    }

    return FareTime(planned: planned, actual: actual)
  }

  func encodeJson() -> [String: AnyObject] {
    var dict: [String: AnyObject] = [:]

    dict["planned"] = planned.encodeJson()
    dict["actual"] = actual.encodeJson()

    return dict
  }
}

extension Melding {
  static func decodeJson(json: AnyObject) throws -> Melding {
    guard let dict = json as? [String : AnyObject] else {
      throw JsonDecodeError.WrongType(rawValue: json, expectedType: "Object")
    }

    var errors: [String: JsonDecodeError] = [:]

    var id_optional: String?
    var ernstig_optional: Bool?
    var text_optional: String?

    if let id_field: AnyObject = dict["id"] {
      do {
        id_optional = try String.decodeJson(id_field)
      }
      catch let error as JsonDecodeError {
        errors["id"] = error
      }
    }
    else {
      errors["id"] = JsonDecodeError.MissingField
    }

    if let ernstig_field: AnyObject = dict["ernstig"] {
      do {
        ernstig_optional = try Bool.decodeJson(ernstig_field)
      }
      catch let error as JsonDecodeError {
        errors["ernstig"] = error
      }
    }
    else {
      errors["ernstig"] = JsonDecodeError.MissingField
    }

    if let text_field: AnyObject = dict["text"] {
      do {
        text_optional = try String.decodeJson(text_field)
      }
      catch let error as JsonDecodeError {
        errors["text"] = error
      }
    }
    else {
      errors["text"] = JsonDecodeError.MissingField
    }

    guard
      let id = id_optional,
      let ernstig = ernstig_optional,
      let text = text_optional
    else {
      throw JsonDecodeError.StructErrors(type: "Melding", errors: errors)
    }

    return Melding(id: id, ernstig: ernstig, text: text)
  }

  func encodeJson() -> [String: AnyObject] {
    var dict: [String: AnyObject] = [:]

    dict["id"] = id.encodeJson()
    dict["ernstig"] = ernstig.encodeJson()
    dict["text"] = text.encodeJson()

    return dict
  }
}

extension Stop {
  static func decodeJson(json: AnyObject) throws -> Stop {
    guard let dict = json as? [String : AnyObject] else {
      throw JsonDecodeError.WrongType(rawValue: json, expectedType: "Object")
    }

    var errors: [String: JsonDecodeError] = [:]

    var time_optional: Double?
    var spoor_optional: String??
    var name_optional: String?

    if let time_field: AnyObject = dict["time"] {
      do {
        time_optional = try Double.decodeJson(time_field)
      }
      catch let error as JsonDecodeError {
        errors["time"] = error
      }
    }
    else {
      errors["time"] = JsonDecodeError.MissingField
    }

    let spoor_field: AnyObject? = dict["spoor"]
    if let spoor_field = spoor_field where !(spoor_field is NSNull) {
      do {
        spoor_optional = try Optional.decodeJson({ try String.decodeJson($0) }, spoor_field)
      }
      catch let error as JsonDecodeError {
        errors["spoor"] = error
      }
    }
    else {
      spoor_optional = .Some(nil)
    }

    if let name_field: AnyObject = dict["name"] {
      do {
        name_optional = try String.decodeJson(name_field)
      }
      catch let error as JsonDecodeError {
        errors["name"] = error
      }
    }
    else {
      errors["name"] = JsonDecodeError.MissingField
    }

    guard
      let time = time_optional,
      let spoor = spoor_optional,
      let name = name_optional
    else {
      throw JsonDecodeError.StructErrors(type: "Stop", errors: errors)
    }

    return Stop(time: time, spoor: spoor, name: name)
  }

  func encodeJson() -> [String: AnyObject] {
    var dict: [String: AnyObject] = [:]

    dict["time"] = time.encodeJson()
    dict["spoor"] = spoor.encodeJson({ $0.encodeJson() })
    dict["name"] = name.encodeJson()

    return dict
  }
}

extension ReisDeel {
  static func decodeJson(json: AnyObject) throws -> ReisDeel {
    guard let dict = json as? [String : AnyObject] else {
      throw JsonDecodeError.WrongType(rawValue: json, expectedType: "Object")
    }

    var errors: [String: JsonDecodeError] = [:]

    var vervoerder_optional: String?
    var vervoerType_optional: String?
    var stops_optional: [Stop]?

    if let vervoerder_field: AnyObject = dict["vervoerder"] {
      do {
        vervoerder_optional = try String.decodeJson(vervoerder_field)
      }
      catch let error as JsonDecodeError {
        errors["vervoerder"] = error
      }
    }
    else {
      errors["vervoerder"] = JsonDecodeError.MissingField
    }

    if let vervoerType_field: AnyObject = dict["vervoerType"] {
      do {
        vervoerType_optional = try String.decodeJson(vervoerType_field)
      }
      catch let error as JsonDecodeError {
        errors["vervoerType"] = error
      }
    }
    else {
      errors["vervoerType"] = JsonDecodeError.MissingField
    }

    if let stops_field: AnyObject = dict["stops"] {
      do {
        stops_optional = try Array.decodeJson({ try Stop.decodeJson($0) }, stops_field)
      }
      catch let error as JsonDecodeError {
        errors["stops"] = error
      }
    }
    else {
      errors["stops"] = JsonDecodeError.MissingField
    }

    guard
      let vervoerder = vervoerder_optional,
      let vervoerType = vervoerType_optional,
      let stops = stops_optional
    else {
      throw JsonDecodeError.StructErrors(type: "ReisDeel", errors: errors)
    }

    return ReisDeel(vervoerder: vervoerder, vervoerType: vervoerType, stops: stops)
  }

  func encodeJson() -> [String: AnyObject] {
    var dict: [String: AnyObject] = [:]

    dict["vervoerder"] = vervoerder.encodeJson()
    dict["vervoerType"] = vervoerType.encodeJson()
    dict["stops"] = stops.encodeJson({ $0.encodeJson() })

    return dict
  }
}

extension Advice {
  static func decodeJson(json: AnyObject) throws -> Advice {
    guard let dict = json as? [String : AnyObject] else {
      throw JsonDecodeError.WrongType(rawValue: json, expectedType: "Object")
    }

    var errors: [String: JsonDecodeError] = [:]

    var overstappen_optional: Int?
    var vertrek_optional: FareTime?
    var melding_optional: Melding??
    var reisDeel_optional: [ReisDeel]?
    var vertrekVertraging_optional: String??
    var status_optional: String?

    if let overstappen_field: AnyObject = dict["overstappen"] {
      do {
        overstappen_optional = try Int.decodeJson(overstappen_field)
      }
      catch let error as JsonDecodeError {
        errors["overstappen"] = error
      }
    }
    else {
      errors["overstappen"] = JsonDecodeError.MissingField
    }

    if let vertrek_field: AnyObject = dict["vertrek"] {
      do {
        vertrek_optional = try FareTime.decodeJson(vertrek_field)
      }
      catch let error as JsonDecodeError {
        errors["vertrek"] = error
      }
    }
    else {
      errors["vertrek"] = JsonDecodeError.MissingField
    }

    let melding_field: AnyObject? = dict["melding"]
    if let melding_field = melding_field where !(melding_field is NSNull) {
      do {
        melding_optional = try Optional.decodeJson({ try Melding.decodeJson($0) }, melding_field)
      }
      catch let error as JsonDecodeError {
        errors["melding"] = error
      }
    }
    else {
      melding_optional = .Some(nil)
    }

    if let reisDeel_field: AnyObject = dict["reisDeel"] {
      do {
        reisDeel_optional = try Array.decodeJson({ try ReisDeel.decodeJson($0) }, reisDeel_field)
      }
      catch let error as JsonDecodeError {
        errors["reisDeel"] = error
      }
    }
    else {
      errors["reisDeel"] = JsonDecodeError.MissingField
    }

    let vertrekVertraging_field: AnyObject? = dict["vertrekVertraging"]
    if let vertrekVertraging_field = vertrekVertraging_field where !(vertrekVertraging_field is NSNull) {
      do {
        vertrekVertraging_optional = try Optional.decodeJson({ try String.decodeJson($0) }, vertrekVertraging_field)
      }
      catch let error as JsonDecodeError {
        errors["vertrekVertraging"] = error
      }
    }
    else {
      vertrekVertraging_optional = .Some(nil)
    }

    if let status_field: AnyObject = dict["status"] {
      do {
        status_optional = try String.decodeJson(status_field)
      }
      catch let error as JsonDecodeError {
        errors["status"] = error
      }
    }
    else {
      errors["status"] = JsonDecodeError.MissingField
    }

    guard
      let overstappen = overstappen_optional,
      let vertrek = vertrek_optional,
      let melding = melding_optional,
      let reisDeel = reisDeel_optional,
      let vertrekVertraging = vertrekVertraging_optional,
      let status = status_optional
    else {
      throw JsonDecodeError.StructErrors(type: "Advice", errors: errors)
    }

    return Advice(overstappen: overstappen, vertrek: vertrek, melding: melding, reisDeel: reisDeel, vertrekVertraging: vertrekVertraging, status: status)
  }

  func encodeJson() -> [String: AnyObject] {
    var dict: [String: AnyObject] = [:]

    dict["overstappen"] = overstappen.encodeJson()
    dict["vertrek"] = vertrek.encodeJson()
    dict["melding"] = melding.encodeJson({ $0.encodeJson() })
    dict["reisDeel"] = reisDeel.encodeJson({ $0.encodeJson() })
    dict["vertrekVertraging"] = vertrekVertraging.encodeJson({ $0.encodeJson() })
    dict["status"] = status.encodeJson()

    return dict
  }
}

extension AdvicesResult {
  static func decodeJson(json: AnyObject) throws -> AdvicesResult {
    guard let dict = json as? [String : AnyObject] else {
      throw JsonDecodeError.WrongType(rawValue: json, expectedType: "Object")
    }

    var errors: [String: JsonDecodeError] = [:]

    var advices_optional: [Advice]?

    if let advices_field: AnyObject = dict["advices"] {
      do {
        advices_optional = try Array.decodeJson({ try Advice.decodeJson($0) }, advices_field)
      }
      catch let error as JsonDecodeError {
        errors["advices"] = error
      }
    }
    else {
      errors["advices"] = JsonDecodeError.MissingField
    }

    guard
      let advices = advices_optional
    else {
      throw JsonDecodeError.StructErrors(type: "AdvicesResult", errors: errors)
    }

    return AdvicesResult(advices: advices)
  }

  func encodeJson() -> [String: AnyObject] {
    var dict: [String: AnyObject] = [:]

    dict["advices"] = advices.encodeJson({ $0.encodeJson() })

    return dict
  }
}
