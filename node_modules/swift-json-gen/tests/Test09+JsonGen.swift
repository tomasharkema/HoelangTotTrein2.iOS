//
//  Test09+JsonGen.swift
//
//  Auto generated by swift-json-gen on Thu, 05 Nov 2015 07:19:20 GMT
//  See for details: https://github.com/tomlokhorst/swift-json-gen
//

import Foundation

extension Test09 {
  static func decodeJson(json: AnyObject) throws -> Test09 {
    guard let dict = json as? [String : AnyObject] else {
      throw JsonDecodeError.WrongType(rawValue: json, expectedType: "Object")
    }

    var errors: [String: JsonDecodeError] = [:]

    var one_optional: Int?
    var intSub1_optional: Sub1<Int>?
    var stringSub1_optional: Sub1<String>?
    var sub2_optional: Sub2<Int, Bool>?
    var sub3_optional: Sub3<Int, Int, String>?

    if let one_field: AnyObject = dict["one"] {
      do {
        one_optional = try Int.decodeJson(one_field)
      }
      catch let error as JsonDecodeError {
        errors["one"] = error
      }
    }
    else {
      errors["one"] = JsonDecodeError.MissingField
    }

    if let intSub1_field: AnyObject = dict["intSub1"] {
      do {
        intSub1_optional = try Sub1.decodeJson({ try Int.decodeJson($0) }, intSub1_field)
      }
      catch let error as JsonDecodeError {
        errors["intSub1"] = error
      }
    }
    else {
      errors["intSub1"] = JsonDecodeError.MissingField
    }

    if let stringSub1_field: AnyObject = dict["stringSub1"] {
      do {
        stringSub1_optional = try Sub1.decodeJson({ try String.decodeJson($0) }, stringSub1_field)
      }
      catch let error as JsonDecodeError {
        errors["stringSub1"] = error
      }
    }
    else {
      errors["stringSub1"] = JsonDecodeError.MissingField
    }

    if let sub2_field: AnyObject = dict["sub2"] {
      do {
        sub2_optional = try Sub2.decodeJson({ try Int.decodeJson($0) }, { try Bool.decodeJson($0) }, sub2_field)
      }
      catch let error as JsonDecodeError {
        errors["sub2"] = error
      }
    }
    else {
      errors["sub2"] = JsonDecodeError.MissingField
    }

    if let sub3_field: AnyObject = dict["sub3"] {
      do {
        sub3_optional = try Sub3.decodeJson({ try Int.decodeJson($0) }, { try Int.decodeJson($0) }, { try String.decodeJson($0) }, sub3_field)
      }
      catch let error as JsonDecodeError {
        errors["sub3"] = error
      }
    }
    else {
      errors["sub3"] = JsonDecodeError.MissingField
    }

    guard
      let one = one_optional,
      let intSub1 = intSub1_optional,
      let stringSub1 = stringSub1_optional,
      let sub2 = sub2_optional,
      let sub3 = sub3_optional
    else {
      throw JsonDecodeError.StructErrors(type: "Test09", errors: errors)
    }

    return Test09(one: one, intSub1: intSub1, stringSub1: stringSub1, sub2: sub2, sub3: sub3)
  }

  func encodeJson() -> [String: AnyObject] {
    var dict: [String: AnyObject] = [:]

    dict["one"] = one.encodeJson()
    dict["intSub1"] = intSub1.encodeJson({ $0.encodeJson() })
    dict["stringSub1"] = stringSub1.encodeJson({ $0.encodeJson() })
    dict["sub2"] = sub2.encodeJson({ $0.encodeJson() }, { $0.encodeJson() })
    dict["sub3"] = sub3.encodeJson({ $0.encodeJson() }, { $0.encodeJson() }, { $0.encodeJson() })

    return dict
  }
}

extension Sub1 {
  static func decodeJson(decodeT: AnyObject throws -> T, _ json: AnyObject) throws -> Sub1 {
    guard let dict = json as? [String : AnyObject] else {
      throw JsonDecodeError.WrongType(rawValue: json, expectedType: "Object")
    }

    var errors: [String: JsonDecodeError] = [:]

    var one_optional: Bool?
    var value_optional: T?

    if let one_field: AnyObject = dict["one"] {
      do {
        one_optional = try Bool.decodeJson(one_field)
      }
      catch let error as JsonDecodeError {
        errors["one"] = error
      }
    }
    else {
      errors["one"] = JsonDecodeError.MissingField
    }

    if let value_field: AnyObject = dict["value"] {
      do {
        value_optional = try decodeT(value_field)
      }
      catch let error as JsonDecodeError {
        errors["value"] = error
      }
    }
    else {
      errors["value"] = JsonDecodeError.MissingField
    }

    guard
      let one = one_optional,
      let value = value_optional
    else {
      throw JsonDecodeError.StructErrors(type: "Sub1", errors: errors)
    }

    return Sub1(one: one, value: value)
  }

  func encodeJson(encodeT: T -> AnyObject) -> [String: AnyObject] {
    var dict: [String: AnyObject] = [:]

    dict["one"] = one.encodeJson()
    dict["value"] = encodeT(value)

    return dict
  }
}

extension Sub2 {
  static func decodeJson(decodeA: AnyObject throws -> A, _ decodeB: AnyObject throws -> B, _ json: AnyObject) throws -> Sub2 {
    guard let dict = json as? [String : AnyObject] else {
      throw JsonDecodeError.WrongType(rawValue: json, expectedType: "Object")
    }

    var errors: [String: JsonDecodeError] = [:]

    var a_optional: A?
    var b_optional: B??
    var c_optional: [[B?]?]??

    if let a_field: AnyObject = dict["a"] {
      do {
        a_optional = try decodeA(a_field)
      }
      catch let error as JsonDecodeError {
        errors["a"] = error
      }
    }
    else {
      errors["a"] = JsonDecodeError.MissingField
    }

    let b_field: AnyObject? = dict["b"]
    if let b_field = b_field where !(b_field is NSNull) {
      do {
        b_optional = try Optional.decodeJson({ try decodeB($0) }, b_field)
      }
      catch let error as JsonDecodeError {
        errors["b"] = error
      }
    }
    else {
      b_optional = .Some(nil)
    }

    let c_field: AnyObject? = dict["c"]
    if let c_field = c_field where !(c_field is NSNull) {
      do {
        c_optional = try Optional.decodeJson({ try Array.decodeJson({ try Optional.decodeJson({ try Array.decodeJson({ try Optional.decodeJson({ try decodeB($0) }, $0) }, $0) }, $0) }, $0) }, c_field)
      }
      catch let error as JsonDecodeError {
        errors["c"] = error
      }
    }
    else {
      c_optional = .Some(nil)
    }

    guard
      let a = a_optional,
      let b = b_optional,
      let c = c_optional
    else {
      throw JsonDecodeError.StructErrors(type: "Sub2", errors: errors)
    }

    return Sub2(a: a, b: b, c: c)
  }

  func encodeJson(encodeA: A -> AnyObject, _ encodeB: B -> AnyObject) -> [String: AnyObject] {
    var dict: [String: AnyObject] = [:]

    dict["a"] = encodeA(a)
    dict["b"] = b.encodeJson({ encodeB($0) })
    dict["c"] = c.encodeJson({ $0.encodeJson({ $0.encodeJson({ $0.encodeJson({ $0.encodeJson({ encodeB($0) }) }) }) }) })

    return dict
  }
}

extension Sub3 {
  static func decodeJson(decodeA: AnyObject throws -> A, _ decodeB: AnyObject throws -> B, _ decodeC: AnyObject throws -> C, _ json: AnyObject) throws -> Sub3 {
    guard let dict = json as? [String : AnyObject] else {
      throw JsonDecodeError.WrongType(rawValue: json, expectedType: "Object")
    }

    var errors: [String: JsonDecodeError] = [:]

    var a1_optional: A?
    var a2_optional: A?
    var b_optional: B??
    var c_optional: [C]?
    var sub2_optional: Sub2<B, A>?

    if let a1_field: AnyObject = dict["a1"] {
      do {
        a1_optional = try decodeA(a1_field)
      }
      catch let error as JsonDecodeError {
        errors["a1"] = error
      }
    }
    else {
      errors["a1"] = JsonDecodeError.MissingField
    }

    if let a2_field: AnyObject = dict["a2"] {
      do {
        a2_optional = try decodeA(a2_field)
      }
      catch let error as JsonDecodeError {
        errors["a2"] = error
      }
    }
    else {
      errors["a2"] = JsonDecodeError.MissingField
    }

    let b_field: AnyObject? = dict["b"]
    if let b_field = b_field where !(b_field is NSNull) {
      do {
        b_optional = try Optional.decodeJson({ try decodeB($0) }, b_field)
      }
      catch let error as JsonDecodeError {
        errors["b"] = error
      }
    }
    else {
      b_optional = .Some(nil)
    }

    if let c_field: AnyObject = dict["c"] {
      do {
        c_optional = try Array.decodeJson({ try decodeC($0) }, c_field)
      }
      catch let error as JsonDecodeError {
        errors["c"] = error
      }
    }
    else {
      errors["c"] = JsonDecodeError.MissingField
    }

    if let sub2_field: AnyObject = dict["sub2"] {
      do {
        sub2_optional = try Sub2.decodeJson({ try decodeB($0) }, { try decodeA($0) }, sub2_field)
      }
      catch let error as JsonDecodeError {
        errors["sub2"] = error
      }
    }
    else {
      errors["sub2"] = JsonDecodeError.MissingField
    }

    guard
      let a1 = a1_optional,
      let a2 = a2_optional,
      let b = b_optional,
      let c = c_optional,
      let sub2 = sub2_optional
    else {
      throw JsonDecodeError.StructErrors(type: "Sub3", errors: errors)
    }

    return Sub3(a1: a1, a2: a2, b: b, c: c, sub2: sub2)
  }

  func encodeJson(encodeA: A -> AnyObject, _ encodeB: B -> AnyObject, _ encodeC: C -> AnyObject) -> [String: AnyObject] {
    var dict: [String: AnyObject] = [:]

    dict["a1"] = encodeA(a1)
    dict["a2"] = encodeA(a2)
    dict["b"] = b.encodeJson({ encodeB($0) })
    dict["c"] = c.encodeJson({ encodeC($0) })
    dict["sub2"] = sub2.encodeJson({ encodeB($0) }, { encodeA($0) })

    return dict
  }
}
