//
//  ErrorJson+JsonGen.swift
//
//  Auto generated by swift-json-gen on Thu, 06 Aug 2015 13:12:53 GMT
//

import Foundation

extension BadRequestJson {
  static func decodeJson(json: AnyObject) -> BadRequestJson? {
    guard let dict = json as? [String : AnyObject] else {
      assertionFailure("json not a dictionary");
      return nil
    }

    guard let error_field: AnyObject? = dict["error"] else {
      assertionFailure("field 'error' is missing")
      return nil
    }
    guard let error: String = String.decodeJson(error_field!) else {
      assertionFailure("field 'error' is not a String")
      return nil
    }

    let error_description_field: AnyObject? = dict["error_description"]
    let error_description: String? = error_description_field == nil ? nil : Optional.decodeJson({ String.decodeJson($0) }, error_description_field!)

    return BadRequestJson(error: error, error_description: error_description)
  }

  func encodeJson() -> AnyObject {
    var dict: [String: AnyObject] = [:]

    dict["error"] = error.encodeJson()
    dict["error_description"] = error_description.encodeJson({ $0.encodeJson() })

    return dict
  }
}

extension ServerErrorJson {
  static func decodeJson(json: AnyObject) -> ServerErrorJson? {
    guard let dict = json as? [String : AnyObject] else {
      assertionFailure("json not a dictionary");
      return nil
    }

    let message_field: AnyObject? = dict["message"]
    let message: String? = message_field == nil ? nil : Optional.decodeJson({ String.decodeJson($0) }, message_field!)

    let exceptionMessage_field: AnyObject? = dict["exceptionMessage"]
    let exceptionMessage: String? = exceptionMessage_field == nil ? nil : Optional.decodeJson({ String.decodeJson($0) }, exceptionMessage_field!)

    let exceptionType_field: AnyObject? = dict["exceptionType"]
    let exceptionType: String? = exceptionType_field == nil ? nil : Optional.decodeJson({ String.decodeJson($0) }, exceptionType_field!)

    let stackTrace_field: AnyObject? = dict["stackTrace"]
    let stackTrace: String? = stackTrace_field == nil ? nil : Optional.decodeJson({ String.decodeJson($0) }, stackTrace_field!)

    return ServerErrorJson(message: message, exceptionMessage: exceptionMessage, exceptionType: exceptionType, stackTrace: stackTrace)
  }

  func encodeJson() -> AnyObject {
    var dict: [String: AnyObject] = [:]

    dict["message"] = message.encodeJson({ $0.encodeJson() })
    dict["exceptionMessage"] = exceptionMessage.encodeJson({ $0.encodeJson() })
    dict["exceptionType"] = exceptionType.encodeJson({ $0.encodeJson() })
    dict["stackTrace"] = stackTrace.encodeJson({ $0.encodeJson() })

    return dict
  }
}

extension AppUpdateRequiredJson {
  static func decodeJson(json: AnyObject) -> AppUpdateRequiredJson? {
    guard let dict = json as? [String : AnyObject] else {
      assertionFailure("json not a dictionary");
      return nil
    }

    guard let infoUrl_field: AnyObject? = dict["infoUrl"] else {
      assertionFailure("field 'infoUrl' is missing")
      return nil
    }
    guard let infoUrl: String = String.decodeJson(infoUrl_field!) else {
      assertionFailure("field 'infoUrl' is not a String")
      return nil
    }

    guard let blocking_field: AnyObject? = dict["blocking"] else {
      assertionFailure("field 'blocking' is missing")
      return nil
    }
    guard let blocking: Bool = Bool.decodeJson(blocking_field!) else {
      assertionFailure("field 'blocking' is not a Bool")
      return nil
    }

    return AppUpdateRequiredJson(infoUrl: infoUrl, blocking: blocking)
  }

  func encodeJson() -> AnyObject {
    var dict: [String: AnyObject] = [:]

    dict["infoUrl"] = infoUrl.encodeJson()
    dict["blocking"] = blocking.encodeJson()

    return dict
  }
}
